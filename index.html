<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
<title>Plant Jump: Avoid Pathogens</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: Arial, sans-serif;
  background: #e0f7e9;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  overflow: hidden;
  touch-action: manipulation;
}
canvas {
  background: white;
  border: 3px solid #4caf50;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  cursor: pointer;
}
#ui {
  position: absolute;
  top: 10px;
  left: 10px;
  color: #2e7d32;
  font-weight: bold;
  font-size: 18px;
  z-index: 10;
}
#instructions {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(255,255,255,0.95);
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  border: 2px solid #4caf50;
  z-index: 20;
}
button {
  background: #4caf50;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  cursor: pointer;
  margin: 10px;
  transition: background 0.3s;
}
button:hover { background: #45a049; }
button:active { background: #3d8b40; }
.credit {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255,255,255,0.8);
  padding: 5px 15px;
  border-radius: 15px;
  font-size: 12px;
  color: #2e7d32;
  font-weight: bold;
}
#leaderboard {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(255,255,255,0.95);
  border: 3px solid #4caf50;
  border-radius: 12px;
  padding: 20px;
  font-size: 14px;
  display: none;
  z-index: 25;
  min-width: 300px;
  text-align: center;
}
#leaderboard h4 {
  color: #2e7d32;
  margin-bottom: 15px;
  font-size: 18px;
}
.score-entry {
  display: flex;
  justify-content: space-between;
  padding: 8px 10px;
  margin: 5px 0;
  background: rgba(76, 175, 80, 0.1);
  border-radius: 8px;
  border-left: 4px solid #4caf50;
}
.score-entry.new-record {
  background: rgba(255, 193, 7, 0.2);
  border-left-color: #ffc107;
  animation: highlight 2s ease-in-out;
}
@keyframes highlight {
  0%, 100% { background: rgba(255, 193, 7, 0.2); }
  50% { background: rgba(255, 193, 7, 0.4); }
}
.rank {
  font-weight: bold;
  color: #2e7d32;
}
.score-value {
  font-weight: bold;
  color: #1976d2;
}
#gameOver {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.9);
  color: white;
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  display: none;
  z-index: 20;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui">
  <div>Score: <span id="score">0</span></div>
  <div>High: <span id="highScore">0</span></div>
  <div id="speedText" style="color: #ff6b35; display: none;"></div>
</div>
<div id="instructions">
  <h3>🪴 Plant Jump</h3>
  <p>Tap screen or press SPACE to jump</p>
  <p>Avoid pathogens: 🦠🪱🧬🍄🧫🐛</p>
  <button onclick="startGame()">Start Game</button>
</div>
<div id="gameOver">
  <h2>Game Over! 💀</h2>
  <p>Score: <span id="finalScore">0</span></p>
  <p id="newRecordMessage" style="color: #ffc107; margin: 10px 0; display: none;">🏆 New High Score!</p>
  <button onclick="showLeaderboard()">View Leaderboard</button>
  <button onclick="restartGame()">Play Again</button>
</div>
<div id="leaderboard">
  <h4>🏆 Top 5 Scores</h4>
  <div id="scoreList"></div>
  <button onclick="hideLeaderboard()">Close</button>
  <button onclick="restartGame()">Play Again</button>
</div>
<div class="credit">Plant Jump by CCG</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// FIXED: Proper responsive canvas sizing
function resizeCanvas() {
  const maxWidth = Math.min(window.innerWidth * 0.95, 1000);
  const maxHeight = Math.min(window.innerHeight * 0.7, 500);

  canvas.width = maxWidth;
  canvas.height = maxHeight;

  // CRITICAL: Ensure CSS matches canvas dimensions
  canvas.style.width = maxWidth + 'px';
  canvas.style.height = maxHeight + 'px';
}

// ADDED: Leaderboard management system
class LeaderboardManager {
  constructor() {
    this.storageKey = 'plantJumpLeaderboard';
    this.maxScores = 5;
  }

  getScores() {
    const stored = localStorage.getItem(this.storageKey);
    return stored ? JSON.parse(stored) : [];
  }

  addScore(newScore) {
    let scores = this.getScores();

    // Add new score with timestamp
    scores.push({
      score: newScore,
      date: new Date().toLocaleDateString(),
      timestamp: Date.now()
    });

    // Sort by score (highest first)
    scores.sort((a, b) => b.score - a.score);

    // Keep only top 5
    scores = scores.slice(0, this.maxScores);

    // Save back to localStorage
    localStorage.setItem(this.storageKey, JSON.stringify(scores));

    // Return the rank of the new score (1-based), or 0 if not in top 5
    const newScoreIndex = scores.findIndex(s => s.score === newScore && s.timestamp === scores.find(sc => sc.score === newScore).timestamp);
    return newScoreIndex >= 0 ? newScoreIndex + 1 : 0;
  }

  getHighScore() {
    const scores = this.getScores();
    return scores.length > 0 ? scores[0].score : 0;
  }

  isNewRecord(score) {
    return score > this.getHighScore();
  }
}

const leaderboard = new LeaderboardManager();

// Game variables
let gameState = 'menu';
let score = 0;
let highScore = leaderboard.getHighScore();
let speed = 6;
let frame = 0;
let restartTapCount = 0;
let newRecordRank = 0;

// Game objects
let plant = {};
let obstacles = [];
let clouds = [];
let particles = [];
let speedEffect = { active: false, timer: 0 };

// Configuration
const CONFIG = {
  gravity: 0.6,
  jumpPower: -11.2,
  doubleJumpPower: -9,
  groundHeight: 60,
  plantSize: 40,
  obstacleSize: 35
};

function initGame() {
  resizeCanvas();
  highScore = leaderboard.getHighScore();
  document.getElementById('highScore').textContent = highScore;

  plant = {
    x: 80,
    y: canvas.height - CONFIG.groundHeight - CONFIG.plantSize,
    width: CONFIG.plantSize,
    height: CONFIG.plantSize,
    dy: 0,
    jumping: false,
    doubleJumpAvailable: false,
    rotation: 0,
    rotationSpeed: 0
  };

  obstacles = [];
  clouds = [];
  particles = [];
  score = 0;
  speed = 6;
  frame = 0;
  speedEffect = { active: false, timer: 0 };
  restartTapCount = 0;
  newRecordRank = 0;

  // Create clouds
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.4,
      size: 20 + Math.random() * 15,
      speed: 0.5 + Math.random() * 1
    });
  }

  document.getElementById('score').textContent = score;
  document.getElementById('speedText').style.display = 'none';
}

function startGame() {
  document.getElementById('instructions').style.display = 'none';
  document.getElementById('gameOver').style.display = 'none';
  document.getElementById('leaderboard').style.display = 'none';
  gameState = 'playing';
  initGame();
  gameLoop();
}

function restartGame() {
  startGame();
}

// ADDED: Leaderboard display functions
function showLeaderboard() {
  document.getElementById('gameOver').style.display = 'none';
  document.getElementById('leaderboard').style.display = 'block';
  updateLeaderboardDisplay();
}

function hideLeaderboard() {
  document.getElementById('leaderboard').style.display = 'none';
  document.getElementById('gameOver').style.display = 'block';
}

function updateLeaderboardDisplay() {
  const scores = leaderboard.getScores();
  const scoreList = document.getElementById('scoreList');

  if (scores.length === 0) {
    scoreList.innerHTML = '<div style="color: #666; font-style: italic;">No scores yet. Be the first!</div>';
    return;
  }

  let html = '';
  scores.forEach((scoreData, index) => {
    const rank = index + 1;
    const isNewRecord = rank === newRecordRank;
    const rankEmoji = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : '🏅';

    html += `
      <div class="score-entry ${isNewRecord ? 'new-record' : ''}">
        <span class="rank">${rankEmoji} #${rank}</span>
        <span class="score-value">${scoreData.score}</span>
      </div>
    `;
  });

  scoreList.innerHTML = html;
}

function jump() {
  if (gameState === 'playing' && !plant.jumping) {
    plant.dy = CONFIG.jumpPower;
    plant.jumping = true;
    plant.doubleJumpAvailable = true;
    plant.rotationSpeed = 15;
  } else if (gameState === 'playing' && plant.jumping && plant.doubleJumpAvailable && plant.dy > -5) {
    plant.dy = CONFIG.doubleJumpPower;
    plant.doubleJumpAvailable = false;
    plant.rotationSpeed = 20;
  } else if (gameState === 'gameOver') {
    restartTapCount++;
    if (restartTapCount >= 3) {
      restartTapCount = 0;
      restartGame();
    }
  }
}

function spawnObstacle() {
  const commonPathogens = ['🦠','🪱','🍄'];
  const rarePathogens = ['🧬','🧫','🐛'];

  let selectedPathogen;
  const rand = Math.random();

  if (rand < 0.7) {
    selectedPathogen = commonPathogens[Math.floor(Math.random() * commonPathogens.length)];
  } else {
    selectedPathogen = rarePathogens[Math.floor(Math.random() * rarePathogens.length)];
  }

  const shouldFloat = score >= 5000 && Math.random() < 0.3;

  obstacles.push({
    x: canvas.width,
    y: canvas.height - CONFIG.groundHeight - CONFIG.obstacleSize,
    width: CONFIG.obstacleSize,
    height: CONFIG.obstacleSize,
    emoji: selectedPathogen,
    floating: shouldFloat,
    floatOffset: 0,
    floatSpeed: 0.05 + Math.random() * 0.03,
    baseY: canvas.height - CONFIG.groundHeight - CONFIG.obstacleSize
  });
}

function createSpeedEffect(type) {
  speedEffect.active = true;
  speedEffect.timer = type === 'super' ? 60 : 30;
  particles = [];

  const count = type === 'super' ? 15 : 8;
  for (let i = 0; i < count; i++) {
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      life: 25 + Math.random() * 15,
      maxLife: 25 + Math.random() * 15,
      type: 'spark'
    });
  }

  const speedText = document.getElementById('speedText');
  speedText.textContent = type === 'super' ? '⚡ SUPER SPEED! ⚡' : '💨 Speed Up! 💨';
  speedText.style.display = 'block';
  setTimeout(() => {
    speedText.style.display = 'none';
  }, 1000);
}

function update() {
  if (gameState !== 'playing') return;

  frame++;

  // Update plant
  plant.y += plant.dy;
  plant.dy += CONFIG.gravity;

  if (plant.jumping) {
    plant.rotation += plant.rotationSpeed;
    plant.rotationSpeed *= 0.95;
  } else {
    plant.rotation = 0;
  }

  if (plant.y > canvas.height - CONFIG.groundHeight - plant.height) {
    plant.y = canvas.height - CONFIG.groundHeight - plant.height;
    plant.dy = 0;
    plant.jumping = false;
    plant.doubleJumpAvailable = false;
    plant.rotation = 0;
    plant.rotationSpeed = 0;
  }

  // Update clouds
  clouds.forEach(cloud => {
    cloud.x -= cloud.speed;
    if (cloud.x + cloud.size < 0) {
      cloud.x = canvas.width + cloud.size;
      cloud.y = Math.random() * canvas.height * 0.4;
    }
  });

  if (frame % 100 === 0) {
    spawnObstacle();
  }

  // Update obstacles
  obstacles.forEach(obs => {
    obs.x -= speed;

    if (obs.floating) {
      obs.floatOffset += obs.floatSpeed;
      const floatRange = 40;
      obs.y = obs.baseY + Math.sin(obs.floatOffset) * floatRange;
    }
  });
  obstacles = obstacles.filter(obs => obs.x + obs.width > 0);

  // Collision detection
  for (let obs of obstacles) {
    if (plant.x < obs.x + obs.width - 8 &&
        plant.x + plant.width > obs.x + 8 &&
        plant.y < obs.y + obs.height - 8 &&
        plant.y + plant.height > obs.y + 8) {

      // ADDED: Handle game over with leaderboard
      gameState = 'gameOver';
      document.getElementById('finalScore').textContent = score;

      // Add score to leaderboard and check if it's a new record
      newRecordRank = leaderboard.addScore(score);

      // Update high score display
      const newHighScore = leaderboard.getHighScore();
      if (newHighScore > highScore) {
        highScore = newHighScore;
        document.getElementById('highScore').textContent = highScore;
        document.getElementById('newRecordMessage').style.display = 'block';
      } else {
        document.getElementById('newRecordMessage').style.display = 'none';
      }

      document.getElementById('gameOver').style.display = 'block';
      return;
    }
  }

  score++;
  document.getElementById('score').textContent = score;

  if (score % 1000 === 0) {
    speed += 1.5;
    createSpeedEffect('super');
  } else if (score % 100 === 0) {
    speed += 0.5;
    createSpeedEffect('normal');
  }

  // Update particles
  if (speedEffect.active) {
    speedEffect.timer--;
    if (speedEffect.timer <= 0) {
      speedEffect.active = false;
      particles = [];
    } else {
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vx *= 0.98;
        p.vy *= 0.98;
        return p.life > 0;
      });
    }
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Sky gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#87CEEB');
  gradient.addColorStop(1, '#E0F6FF');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw clouds
  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
  clouds.forEach(cloud => {
    ctx.beginPath();
    ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
    ctx.arc(cloud.x + cloud.size * 0.5, cloud.y - cloud.size * 0.2, cloud.size * 0.7, 0, Math.PI * 2);
    ctx.arc(cloud.x - cloud.size * 0.5, cloud.y + cloud.size * 0.2, cloud.size * 0.7, 0, Math.PI * 2);
    ctx.fill();
  });

  // Draw ground
  ctx.fillStyle = '#4CAF50';
  ctx.fillRect(0, canvas.height - CONFIG.groundHeight, canvas.width, CONFIG.groundHeight);

  // Draw particles
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2 + alpha * 2, 0, Math.PI * 2);
    ctx.fill();
  });

  if (speedEffect.active && speedEffect.timer > 50) {
    const flashAlpha = (speedEffect.timer - 50) / 10;
    ctx.fillStyle = `rgba(255, 200, 100, ${flashAlpha * 0.05})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // Draw plant
  ctx.save();
  ctx.translate(plant.x + plant.width/2, plant.y + plant.height/2);
  ctx.rotate((plant.rotation * Math.PI) / 180);
  ctx.font = `${CONFIG.plantSize}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('🪴', 0, 0);
  ctx.restore();

  // Draw obstacles
  ctx.font = `${CONFIG.obstacleSize}px Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  obstacles.forEach(obs => {
    ctx.fillText(obs.emoji, obs.x + obs.width/2, obs.y + obs.height/2);
  });
}

function gameLoop() {
  update();
  render();
  if (gameState === 'playing') {
    requestAnimationFrame(gameLoop);
  }
}

// Event listeners
canvas.addEventListener('click', jump);
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  jump();
});

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    jump();
  }
});

window.addEventListener('resize', resizeCanvas);

// Initialize
resizeCanvas();
document.getElementById('highScore').textContent = highScore;
</script>
</body>
</html>
