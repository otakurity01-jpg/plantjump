<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
<title>Plant Jump: Avoid Pathogens</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: Arial, sans-serif;
  background: #e0f7e9;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  overflow: hidden;
  touch-action: manipulation;
}
canvas {
  background: white;
  border: 3px solid #4caf50;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  cursor: pointer;
}
#ui {
  position: absolute;
  top: 10px;
  left: 10px;
  color: #2e7d32;
  font-weight: bold;
  font-size: 18px;
  z-index: 10;
}
#instructions {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(255,255,255,0.95);
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  border: 2px solid #4caf50;
  z-index: 20;
}
button {
  background: #4caf50;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  cursor: pointer;
  margin: 10px;
  transition: background 0.3s;
}
button:hover { background: #45a049; }
button:active { background: #3d8b40; }
.credit {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255,255,255,0.8);
  padding: 5px 15px;
  border-radius: 15px;
  font-size: 12px;
  color: #2e7d32;
  font-weight: bold;
}
#leaderboard {
  position: absolute;
  top: 10px;
  right: 10px;
  background: rgba(255,255,255,0.9);
  border: 2px solid #4caf50;
  border-radius: 8px;
  padding: 10px;
  font-size: 12px;
  display: none;
}
#gameOver {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.9);
  color: white;
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  display: none;
  z-index: 20;
}
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="400"></canvas>
<div id="ui">
  <div>Score: <span id="score">0</span></div>
  <div>High: <span id="highScore">0</span></div>
  <div id="speedText" style="color: #ff6b35; display: none;"></div>
</div>
<div id="instructions">
  <h3>ü™¥ Plant Jump</h3>
  <p>Tap screen or press SPACE to jump</p>
  <p>Avoid pathogens: ü¶†ü™±üß¨üçÑüß´üêõ</p>
  <button onclick="startGame()">Start Game</button>
</div>
<div id="gameOver">
  <h2>Game Over! üíÄ</h2>
  <p>Score: <span id="finalScore">0</span></p>
  <button onclick="restartGame()">Play Again</button>
</div>
<div id="leaderboard">
  <h4>Top Scores</h4>
  <div id="scoreList"></div>
</div>
<div class="credit">Plant Jump by CCG</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Responsive canvas sizing
function resizeCanvas() {
  const maxWidth = Math.min(window.innerWidth * 0.95, 1000);
  const maxHeight = Math.min(window.innerHeight * 0.7, 500);
  canvas.width = maxWidth;
  canvas.height = maxHeight;
}

// Game variables
let gameState = 'menu'; // 'menu', 'playing', 'gameOver'
let score = 0;
let highScore = parseInt(localStorage.getItem('plantJumpHigh') || '0');
let topScores = JSON.parse(localStorage.getItem('plantJumpTopScores') || '[]');
let speed = 6;
let frame = 0;
let nextSpawnFrame = 120;

// Game objects
let plant = {};
let obstacles = [];
let clouds = [];
let particles = [];
let speedEffect = { active: false, timer: 0 };

// Configuration
const CONFIG = {
  gravity: 0.6,
  jumpPower: -11.2, // 80% of normal (-14)
  groundHeight: 60,
  plantSize: 40,
  obstacleSize: 35,
  minSpawnInterval: 80, // Minimum frames between spawns to ensure jumpable
  maxSpawnInterval: 160 // Maximum frames between spawns
};

function initGame() {
  resizeCanvas();
  // Ensure backward compatibility
  if (highScore > 0 && !topScores.includes(highScore)) {
    topScores.push(highScore);
    topScores.sort((a, b) => b - a);
    topScores = topScores.slice(0, 5);
    localStorage.setItem('plantJumpTopScores', JSON.stringify(topScores));
  }
  highScore = topScores.length ? Math.max(...topScores) : 0;
  document.getElementById('highScore').textContent = highScore;
  
  plant = {
    x: 80,
    y: canvas.height - CONFIG.groundHeight - CONFIG.plantSize,
    width: CONFIG.plantSize,
    height: CONFIG.plantSize,
    dy: 0,
    jumping: false
  };
  
  obstacles = [];
  clouds = [];
  particles = [];
  score = 0;
  speed = 6;
  frame = 0;
  nextSpawnFrame = frame + CONFIG.minSpawnInterval + Math.floor(Math.random() * (CONFIG.maxSpawnInterval - CONFIG.minSpawnInterval));
  speedEffect = { active: false, timer: 0 };
  
  // Create clouds
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.4,
      size: 20 + Math.random() * 15,
      speed: 0.5 + Math.random() * 1
    });
  }
  
  document.getElementById('score').textContent = score;
  document.getElementById('speedText').style.display = 'none';
  document.getElementById('leaderboard').style.display = 'none';
}

function startGame() {
  document.getElementById('instructions').style.display = 'none';
  document.getElementById('gameOver').style.display = 'none';
  gameState = 'playing';
  initGame();
  gameLoop();
}

function restartGame() {
  startGame();
}

function jump() {
  if (gameState === 'playing' && !plant.jumping) {
    plant.dy = CONFIG.jumpPower;
    plant.jumping = true;
  }
}

function spawnObstacle() {
  const pathogens = ['ü¶†','ü™±','üß¨','üçÑ','üß´','üêõ'];
  obstacles.push({
    x: canvas.width,
    y: canvas.height - CONFIG.groundHeight - CONFIG.obstacleSize,
    width: CONFIG.obstacleSize,
    height: CONFIG.obstacleSize,
    emoji: pathogens[Math.floor(Math.random() * pathogens.length)]
  });
}

function createSpeedEffect(type) {
  speedEffect.active = true;
  speedEffect.timer = 30;
  particles = []; // No particles to avoid any blinking effect
  
  // Show speed text
  const speedText = document.getElementById('speedText');
  speedText.textContent = type === 'super' ? '‚ö° SUPER SPEED! ‚ö°' : 'üí® Speed Up! üí®';
  speedText.style.display = 'block';
  setTimeout(() => {
    speedText.style.display = 'none';
  }, 1000);
}

function update() {
  if (gameState !== 'playing') return;
  
  frame++;
  
  // Update plant
  plant.y += plant.dy;
  plant.dy += CONFIG.gravity;
  
  if (plant.y > canvas.height - CONFIG.groundHeight - plant.height) {
    plant.y = canvas.height - CONFIG.groundHeight - plant.height;
    plant.dy = 0;
    plant.jumping = false;
  }
  
  // Update clouds
  clouds.forEach(cloud => {
    cloud.x -= cloud.speed;
    if (cloud.x + cloud.size < 0) {
      cloud.x = canvas.width + cloud.size;
      cloud.y = Math.random() * canvas.height * 0.4;
    }
  });
  
  // Spawn obstacles at random intervals
  if (frame >= nextSpawnFrame) {
    spawnObstacle();
    nextSpawnFrame = frame + CONFIG.minSpawnInterval + Math.floor(Math.random() * (CONFIG.maxSpawnInterval - CONFIG.minSpawnInterval));
  }
  
  // Update obstacles
  obstacles.forEach(obs => obs.x -= speed);
  obstacles = obstacles.filter(obs => obs.x + obs.width > 0);
  
  // Collision detection with more leniency
  for (let obs of obstacles) {
    if (plant.x < obs.x + obs.width - 12 &&
        plant.x + plant.width > obs.x + 12 &&
        plant.y < obs.y + obs.height - 12 &&
        plant.y + plant.height > obs.y + 12) {
      
      gameState = 'gameOver';
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').style.display = 'block';
      
      // Update top scores
      topScores.push(score);
      topScores.sort((a, b) => b - a);
      topScores = topScores.slice(0, 5);
      localStorage.setItem('plantJumpTopScores', JSON.stringify(topScores));
      
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('plantJumpHigh', highScore);
      }
      
      // Populate and show leaderboard with medals
      const scoreList = document.getElementById('scoreList');
      scoreList.innerHTML = '';
      const medals = ['ü•á', 'ü•à', 'ü•â'];
      topScores.forEach((s, i) => {
        const div = document.createElement('div');
        const prefix = i < 3 ? medals[i] : `${i + 1}.`;
        div.textContent = `${prefix} ${s}`;
        scoreList.appendChild(div);
      });
      document.getElementById('leaderboard').style.display = 'block';
      document.getElementById('highScore').textContent = highScore;
      return;
    }
  }
  
  // Update score and speed
  score++;
  document.getElementById('score').textContent = score;
  
  if (score % 100 === 0) {
    speed += 0.3;
    createSpeedEffect(score % 1000 === 0 ? 'super' : 'normal');
  }
  
  // Update particles (empty since no particles)
  if (speedEffect.active) {
    speedEffect.timer--;
    if (speedEffect.timer <= 0) {
      speedEffect.active = false;
      particles = [];
    } else {
      particles = particles.filter(p => p.life > 0);
    }
  }
}

function render() {
  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Sky gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#87CEEB');
  gradient.addColorStop(1, '#E0F6FF');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw clouds
  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
  clouds.forEach(cloud => {
    ctx.beginPath();
    ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
    ctx.arc(cloud.x + cloud.size * 0.5, cloud.y - cloud.size * 0.2, cloud.size * 0.7, 0, Math.PI * 2);
    ctx.arc(cloud.x - cloud.size * 0.5, cloud.y + cloud.size * 0.2, cloud.size * 0.7, 0, Math.PI * 2);
    ctx.fill();
  });
  
  // Draw ground
  ctx.fillStyle = '#4CAF50';
  ctx.fillRect(0, canvas.height - CONFIG.groundHeight, canvas.width, CONFIG.groundHeight);
  
  // No particles drawn
  
  // Draw plant
  ctx.font = `${CONFIG.plantSize}px Arial`;
  ctx.textAlign = 'center';
  ctx.fillText('ü™¥', plant.x + plant.width/2, plant.y + plant.height * 0.8);
  
  // Draw obstacles
  ctx.font = `${CONFIG.obstacleSize}px Arial`;
  obstacles.forEach(obs => {
    ctx.fillText(obs.emoji, obs.x + obs.width/2, obs.y + obs.height * 0.8);
  });
}

function gameLoop() {
  update();
  render();
  if (gameState === 'playing') {
    requestAnimationFrame(gameLoop);
  }
}

// Event listeners
canvas.addEventListener('click', jump);
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  jump();
});

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    jump();
  }
});

window.addEventListener('resize', resizeCanvas);

// Initialize
resizeCanvas();
document.getElementById('highScore').textContent = highScore;
</script>
</body>
</html>
