<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
<title>Plant Jump: Avoid Pathogens</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', Arial, sans-serif;
  background: #e0f7e9;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  overflow: hidden;
  touch-action: manipulation;
}
canvas {
  background: white;
  border: 3px solid #4caf50;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  cursor: pointer;
  display: block; /* Ensure canvas displays properly */
}
#ui {
  position: absolute;
  top: 10px;
  left: 10px;
  color: #2e7d32;
  font-weight: bold;
  font-size: 18px;
  z-index: 10;
}
#instructions {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(255,255,255,0.95);
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  border: 2px solid #4caf50;
  z-index: 20;
}
button {
  background: #4caf50;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  cursor: pointer;
  margin: 10px;
  transition: background 0.3s;
}
button:hover { background: #45a049; }
button:active { background: #3d8b40; }
.credit {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255,255,255,0.8);
  padding: 5px 15px;
  border-radius: 15px;
  font-size: 12px;
  color: #2e7d32;
  font-weight: bold;
}
#leaderboard {
  position: absolute;
  top: 10px;
  right: 10px;
  background: rgba(255,255,255,0.9);
  border: 2px solid #4caf50;
  border-radius: 8px;
  padding: 10px;
  font-size: 12px;
  display: none;
}
#gameOver {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.9);
  color: white;
  padding: 20px;
  border-radius: 12px;
  text-align: center;
  display: none;
  z-index: 20;
}

/* Media queries for better responsiveness */
@media screen and (max-width: 768px) {
  #ui {
    font-size: 16px;
  }
  canvas {
    border-width: 2px;
  }
}

@media screen and (min-width: 1200px) {
  canvas {
    max-width: 1000px;
    max-height: 500px;
  }
}
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="400"></canvas>
<div id="ui">
  <div>Score: <span id="score">0</span></div>
  <div>High: <span id="highScore">0</span></div>
  <div id="speedText" style="color: #ff6b35; display: none;"></div>
</div>
<div id="instructions">
  <h3>🪴 Plant Jump</h3>
  <p>Tap screen or press SPACE to jump</p>
  <p>Avoid pathogens: 🦠🪱🧬🍄🧫🐛</p>
  <button onclick="startGame()">Start Game</button>
</div>
<div id="gameOver">
  <h2>Game Over! 💀</h2>
  <p>Score: <span id="finalScore">0</span></p>
  <button onclick="restartGame()">Play Again</button>
</div>
<div id="leaderboard">
  <h4>Top Scores</h4>
  <div id="scoreList"></div>
</div>
<div class="credit">Plant Jump by CCG</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Check for emoji support and provide fallbacks
function checkEmojiSupport() {
  const testCanvas = document.createElement('canvas');
  const testCtx = testCanvas.getContext('2d');
  testCanvas.width = 32;
  testCanvas.height = 32;

  testCtx.font = '20px Arial';
  testCtx.textAlign = 'center';
  testCtx.textBaseline = 'middle';
  testCtx.fillText('🪴', 16, 16);

  const imageData = testCtx.getImageData(0, 0, 32, 32);
  const data = imageData.data;

  // Check if any pixels are non-transparent (emoji rendered)
  for (let i = 3; i < data.length; i += 4) {
    if (data[i] !== 0) return true;
  }
  return false;
}

const hasEmojiSupport = checkEmojiSupport();

// Responsive canvas sizing with better desktop support
function resizeCanvas() {
  const container = document.body;
  const containerWidth = container.clientWidth;
  const containerHeight = container.clientHeight;

  // Better responsive sizing logic
  let targetWidth, targetHeight;

  if (window.innerWidth <= 768) {
    // Mobile devices
    targetWidth = Math.min(containerWidth * 0.95, 600);
    targetHeight = Math.min(containerHeight * 0.6, 300);
  } else {
    // Desktop and tablets
    targetWidth = Math.min(containerWidth * 0.8, 1000);
    targetHeight = Math.min(containerHeight * 0.7, 500);
  }

  // Maintain aspect ratio
  const aspectRatio = 2; // width:height = 2:1
  if (targetWidth / targetHeight > aspectRatio) {
    targetWidth = targetHeight * aspectRatio;
  } else {
    targetHeight = targetWidth / aspectRatio;
  }

  canvas.width = Math.max(400, targetWidth); // Minimum width
  canvas.height = Math.max(200, targetHeight); // Minimum height

  // Update canvas style for crisp rendering
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';

  // Scale context for high DPI displays
  const dpr = window.devicePixelRatio || 1;
  if (dpr > 1) {
    canvas.width *= dpr;
    canvas.height *= dpr;
    ctx.scale(dpr, dpr);
    canvas.style.width = (canvas.width / dpr) + 'px';
    canvas.style.height = (canvas.height / dpr) + 'px';
  }
}

// Game variables
let gameState = 'menu'; // 'menu', 'playing', 'gameOver'
let score = 0;
let highScore = parseInt(localStorage.getItem('plantJumpHigh') || '0');
let speed = 6;
let frame = 0;
let restartTapCount = 0;

// Game objects
let plant = {};
let obstacles = [];
let clouds = [];
let particles = [];
let speedEffect = { active: false, timer: 0 };

// Configuration with better desktop compatibility
const CONFIG = {
  gravity: 0.6,
  jumpPower: -11.2,
  doubleJumpPower: -9,
  groundHeight: 60,
  plantSize: 40,
  obstacleSize: 35,
  // Fallback symbols if emojis don't work
  plantSymbol: hasEmojiSupport ? '🪴' : 'P',
  obstacleSymbols: hasEmojiSupport ? ['🦠','🪱','🧬','🍄','🧫','🐛'] : ['*','~','@','#','%','&']
};

function initGame() {
  resizeCanvas();
  document.getElementById('highScore').textContent = highScore;

  plant = {
    x: 80,
    y: canvas.height - CONFIG.groundHeight - CONFIG.plantSize,
    width: CONFIG.plantSize,
    height: CONFIG.plantSize,
    dy: 0,
    jumping: false,
    doubleJumpAvailable: false,
    rotation: 0,
    rotationSpeed: 0
  };

  obstacles = [];
  clouds = [];
  particles = [];
  score = 0;
  speed = 6;
  frame = 0;
  speedEffect = { active: false, timer: 0 };
  restartTapCount = 0;

  // Create clouds
  for (let i = 0; i < 6; i++) {
    clouds.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.4,
      size: 20 + Math.random() * 15,
      speed: 0.5 + Math.random() * 1
    });
  }

  document.getElementById('score').textContent = score;
  document.getElementById('speedText').style.display = 'none';
}

function startGame() {
  document.getElementById('instructions').style.display = 'none';
  document.getElementById('gameOver').style.display = 'none';
  gameState = 'playing';
  initGame();
  gameLoop();
}

function restartGame() {
  startGame();
}

function jump() {
  if (gameState === 'playing' && !plant.jumping) {
    plant.dy = CONFIG.jumpPower;
    plant.jumping = true;
    plant.doubleJumpAvailable = true;
    plant.rotationSpeed = 15;
  } else if (gameState === 'playing' && plant.jumping && plant.doubleJumpAvailable && plant.dy > -5) {
    plant.dy = CONFIG.doubleJumpPower;
    plant.doubleJumpAvailable = false;
    plant.rotationSpeed = 20;
  } else if (gameState === 'gameOver') {
    restartTapCount++;
    if (restartTapCount >= 3) {
      restartTapCount = 0;
      restartGame();
    }
  }
}

function spawnObstacle() {
  const commonPathogens = hasEmojiSupport ? ['🦠','🪱','🍄'] : ['*','~','#'];
  const rarePathogens = hasEmojiSupport ? ['🧬','🧫','🐛'] : ['@','%','&'];

  let selectedPathogen;
  const rand = Math.random();

  if (rand < 0.7) {
    selectedPathogen = commonPathogens[Math.floor(Math.random() * commonPathogens.length)];
  } else {
    selectedPathogen = rarePathogens[Math.floor(Math.random() * rarePathogens.length)];
  }

  const shouldFloat = score >= 5000 && Math.random() < 0.3;

  obstacles.push({
    x: canvas.width,
    y: canvas.height - CONFIG.groundHeight - CONFIG.obstacleSize,
    width: CONFIG.obstacleSize,
    height: CONFIG.obstacleSize,
    emoji: selectedPathogen,
    floating: shouldFloat,
    floatOffset: 0,
    floatSpeed: 0.05 + Math.random() * 0.03,
    baseY: canvas.height - CONFIG.groundHeight - CONFIG.obstacleSize
  });
}

function createSpeedEffect(type) {
  speedEffect.active = true;
  speedEffect.timer = type === 'super' ? 60 : 30;
  particles = [];

  const count = type === 'super' ? 15 : 8;
  for (let i = 0; i < count; i++) {
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      vx: (Math.random() - 0.5) * 6,
      vy: (Math.random() - 0.5) * 6,
      life: 25 + Math.random() * 15,
      maxLife: 25 + Math.random() * 15,
      type: 'spark'
    });
  }

  const speedText = document.getElementById('speedText');
  speedText.textContent = type === 'super' ? '⚡ SUPER SPEED! ⚡' : '💨 Speed Up! 💨';
  speedText.style.display = 'block';
  setTimeout(() => {
    speedText.style.display = 'none';
  }, 1000);
}

function update() {
  if (gameState !== 'playing') return;

  frame++;

  // Update plant
  plant.y += plant.dy;
  plant.dy += CONFIG.gravity;

  if (plant.jumping) {
    plant.rotation += plant.rotationSpeed;
    plant.rotationSpeed *= 0.95;
  } else {
    plant.rotation = 0;
  }

  if (plant.y > canvas.height - CONFIG.groundHeight - plant.height) {
    plant.y = canvas.height - CONFIG.groundHeight - plant.height;
    plant.dy = 0;
    plant.jumping = false;
    plant.doubleJumpAvailable = false;
    plant.rotation = 0;
    plant.rotationSpeed = 0;
  }

  // Update clouds
  clouds.forEach(cloud => {
    cloud.x -= cloud.speed;
    if (cloud.x + cloud.size < 0) {
      cloud.x = canvas.width + cloud.size;
      cloud.y = Math.random() * canvas.height * 0.4;
    }
  });

  if (frame % 100 === 0) {
    spawnObstacle();
  }

  // Update obstacles
  obstacles.forEach(obs => {
    obs.x -= speed;

    if (obs.floating) {
      obs.floatOffset += obs.floatSpeed;
      const floatRange = 40;
      obs.y = obs.baseY + Math.sin(obs.floatOffset) * floatRange;
    }
  });
  obstacles = obstacles.filter(obs => obs.x + obs.width > 0);

  // Collision detection
  for (let obs of obstacles) {
    if (plant.x < obs.x + obs.width - 8 &&
        plant.x + plant.width > obs.x + 8 &&
        plant.y < obs.y + obs.height - 8 &&
        plant.y + plant.height > obs.y + 8) {

      gameState = 'gameOver';
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').style.display = 'block';

      if (score > highScore) {
        highScore = score;
        localStorage.setItem('plantJumpHigh', highScore);
        document.getElementById('highScore').textContent = highScore;
      }
      return;
    }
  }

  score++;
  document.getElementById('score').textContent = score;

  if (score % 1000 === 0) {
    speed += 1.5;
    createSpeedEffect('super');
  } else if (score % 100 === 0) {
    speed += 0.5;
    createSpeedEffect('normal');
  }

  // Update particles
  if (speedEffect.active) {
    speedEffect.timer--;
    if (speedEffect.timer <= 0) {
      speedEffect.active = false;
      particles = [];
    } else {
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vx *= 0.98;
        p.vy *= 0.98;
        return p.life > 0;
      });
    }
  }
}

function render() {
  // Clear canvas with proper dimensions
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Sky gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, '#87CEEB');
  gradient.addColorStop(1, '#E0F6FF');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw clouds
  ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
  clouds.forEach(cloud => {
    ctx.beginPath();
    ctx.arc(cloud.x, cloud.y, cloud.size, 0, Math.PI * 2);
    ctx.arc(cloud.x + cloud.size * 0.5, cloud.y - cloud.size * 0.2, cloud.size * 0.7, 0, Math.PI * 2);
    ctx.arc(cloud.x - cloud.size * 0.5, cloud.y + cloud.size * 0.2, cloud.size * 0.7, 0, Math.PI * 2);
    ctx.fill();
  });

  // Draw ground
  ctx.fillStyle = '#4CAF50';
  ctx.fillRect(0, canvas.height - CONFIG.groundHeight, canvas.width, CONFIG.groundHeight);

  // Draw particles
  particles.forEach(p => {
    const alpha = p.life / p.maxLife;
    ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2 + alpha * 2, 0, Math.PI * 2);
    ctx.fill();
  });

  // Screen flash for super speed
  if (speedEffect.active && speedEffect.timer > 50) {
    const flashAlpha = (speedEffect.timer - 50) / 10;
    ctx.fillStyle = `rgba(255, 200, 100, ${flashAlpha * 0.05})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // Draw plant with better font settings
  ctx.save();
  ctx.translate(plant.x + plant.width/2, plant.y + plant.height/2);
  ctx.rotate((plant.rotation * Math.PI) / 180);

  // Better font stack for cross-platform emoji support
  ctx.font = `${CONFIG.plantSize}px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', Arial, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Add fallback for no emoji support
  if (!hasEmojiSupport) {
    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(-CONFIG.plantSize/2, -CONFIG.plantSize/2, CONFIG.plantSize, CONFIG.plantSize);
    ctx.fillStyle = 'white';
    ctx.font = `${CONFIG.plantSize * 0.8}px Arial`;
  }

  ctx.fillText(CONFIG.plantSymbol, 0, 0);
  ctx.restore();

  // Draw obstacles with better font settings
  ctx.font = `${CONFIG.obstacleSize}px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', Arial, sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  obstacles.forEach(obs => {
    if (!hasEmojiSupport) {
      ctx.fillStyle = '#ff4444';
      ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
      ctx.fillStyle = 'white';
      ctx.font = `${CONFIG.obstacleSize * 0.8}px Arial`;
    }
    ctx.fillText(obs.emoji, obs.x + obs.width/2, obs.y + obs.height/2);
  });
}

function gameLoop() {
  update();
  render();
  if (gameState === 'playing') {
    requestAnimationFrame(gameLoop);
  }
}

// Enhanced event listeners with better desktop support
canvas.addEventListener('click', jump);
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  jump();
}, { passive: false });

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    jump();
  }
});

// Better resize handling
window.addEventListener('resize', () => {
  setTimeout(resizeCanvas, 100); // Debounce resize
});

// Initialize with better cross-platform support
window.addEventListener('load', () => {
  resizeCanvas();
  document.getElementById('highScore').textContent = highScore;
});

// Fallback initialization
resizeCanvas();
document.getElementById('highScore').textContent = highScore;
</script>
</body>
</html>
